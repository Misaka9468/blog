# 题目

https://www.luogu.com.cn/problem/P2679

题目大意：

有两个仅包含小写英文字母的字符串 *A* 和 *B*。

现在要从字符串 *A* 中取出 *k* 个互不重叠的非空子串，然后把这 k 个子串按照其在字符串 A 中出现的顺序依次连接起来得到一个新的字符串。**请问有多少种方案可以使得这个新串与字符串 *B* 相等？**

# 思路

我根本没想到dp怎么做。

维护状态，以及新添入字符对整个策略的影响.

**$dp[i][j][k][m]$ 表示A串的前i个字符，B串的前j个字符，对串A有k个选取方法后，满足题目条件的方案数**。其中m=0表明不以A[i]结尾，m=1表明以A[i]结尾。

**那么$dp[i][j][k][0]+dp[i][j][k][1]$即为题目所求**

是怎么想到这个dp的呢？

考虑在已有匹配 $A:aab \quad B:ab$ 的基础上，A后面又加了一个$b$.

**考虑新加入的$b$会对原先整个格局的影响**：



* 若$A[i]\neq B[j]$, 则这个b根本不会被选取，那么
$$dp[i][j][k][1] = 0$$
$$dp[i][j][k][0] = dp[i-1][j][k][0]+dp[i-1][j][k][1]$$ 

（新加入的b根本没影响）



* 若$A[i]== B[j]$, 则分A[i]是否会被选取来判断：

  * 若不选取A[i]，即m=0，那与上文同


  * 若选取A[i]，即m=1：

     * 若被A[i]被纳入原先匹配，即A:ab B:ab，那么+$dp[i-1][j-1][k][1]$ 注意由于我们的A[i]被纳入，即不算新增一个选取划分，那么它前面那个一定被用到了 
     * 若未被纳入，那就是前面的情况 k-1 了。注意要同时加上[0]与[1]


$$dp[i][j][k][0] = dp[i-1][j][k][0]+dp[i-1][j][k][1]$$

$$dp[i][j][k][1] = dp[i-1][j-1][k][1]+ (dp[i-1][j-1][k-1][0]+dp[i-1][j-1][k-1][1])$$

 考虑到会爆，且dp转移表达式只与i-1有关，考虑状态压缩

# 代码

 ```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstring>

using namespace std;
#define MOD 1000000007
char A[1005],B[1005];
int dp[2][201][201][2];
int n,m,k;

int main(){
    scanf("%d%d%d",&n,&m,&k);
    cin>>(A+1);
    cin>>(B+1);
    dp[0][0][0][0] = 1;
    dp[1][0][0][0] = 1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            for(int p=1;p<=k&&p<=j;p++){
                if(A[i]==B[j]){
                    // pick B[j]
                    dp[i&1][j][p][1]=(dp[1-(i&1)][j-1][p][1]+dp[1-(i&1)][j-1][p-1][0])%MOD;
                    dp[i&1][j][p][1]=(dp[i&1][j][p][1]+dp[1-(i&1)][j-1][p-1][1])%MOD;
                    // do not pick B[j]
                    dp[i&1][j][p][0] = (dp[1-(i&1)][j][p][0]+dp[1-(i&1)][j][p][1])%MOD;
                }
                else{
                    dp[i&1][j][p][1] = 0;
                    dp[i&1][j][p][0] = (dp[1-(i&1)][j][p][0]+dp[1-(i&1)][j][p][1])%MOD;
                }
            }
        }
    }
    printf("%d",(dp[n&1][m][k][0]+dp[n&1][m][k][1])%MOD);
    return 0;
}
 ```