参考: https://www.cnblogs.com/henry-1202/p/9307927.html

# 1 二叉堆的原理

**堆是一颗完全二叉树** 【相较于满二叉树，完全二叉树的每个节点所在的位置与都与在满二叉树中的相同】

**堆的顶端一定是“最大”，最小”的**

堆的子树也是堆

# 2 实现二叉堆的模拟增删查

## 2.1 二叉堆的实现

利用数组来实现 

```cpp
Heap[N]
```

对于根节点从1开始计算，$i$ 的子节点为 $i<<1$ 和 $(i << 1) + 1$ 

对于某节点 $i$ , 其父节点为 $i>>1$

## 2.2 二叉堆的增加

从底部加上，如果其和父节点不满足 大/小根堆的性质，则swap，直至到根节点

## 2.3 二叉堆的删除

* **删除根节点：**
  * 如果是小根堆，则swap(根节点,较小的子节点)。 一直swap到叶子节点

## 2.4 二叉堆的查找

我们只求优先级最大/最小的值，因此只需要输出根节点



# 3 STL: 优先队列

```cpp
priority_queue<int> q;//这是一个大根堆q
priority_queue<int,vector<int>,greater<int> >q;//这是一个小根堆q

q.top()//取得堆顶元素，并不会弹出
q.pop()//弹出堆顶元素
q.push()//往堆里面插入一个元素
q.empty()//查询堆是否为空，为空则返回1否则返回0
q.size()//查询堆内元素数量
```

不过有个小问题就是STL只支持删除堆顶，而不支持删除其他元素

但是问题不大，开一个数组del，在要删除其他元素的时候直接就标记一下del[i]=1，**这里的下标是元素的值**，然后在查询的时候碰到这个元素被标记了直接弹出然后继续查询就可以了 



**如何对结构体进行排序呢？运算符重载**

**定义一个cmp结构体，其里面再重载两个struct对象进行重载**

```cpp
 struct cmp1{
    bool operator()(pair<int,int> a, pair<int, int> b){
        return a.second > b.second;
    }
};
priority_queue<pair<int,int> , vector<pair<int,int>>, cmp1> q;
```

