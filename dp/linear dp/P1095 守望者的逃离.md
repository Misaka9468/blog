# 题目

https://www.luogu.com.cn/problem/P1095

大致题意：

要逃离一个地方。

每秒跑17m，如果使用闪现能跑60m，但是魔力-10.

休息一次魔力+4.

给定逃跑距离，初始魔力，剩余时间。判断能否跑出，不能跑出则给出最远逃跑距离。

# 思路

1. 一开始我是想用memo search，使用t与m的二维状态装进map，用于剪枝，后来发现超时并且并不准确。
2. 也不可能用这两个做成数组，因为两个的数据范围太大，弄成int数组肯定mle.
3. 贪心做法是正确的，即>10能闪则闪。
4. **dp[i]代表了在t=i时，所能到达的最远距离**
4. 我比较认可的dp做法。先用if (m>10) dp[i] = 60 + dp[i-1] else dp[i-1]

  这是闪现的，t = i 所到达的而最远距离，之后再考虑如果这次用跑步会不会更佳。而且这样做也很容易算出t=几时，就会超。

 5. 为什么第二次，也就是使用跑步来代替flash的时候，不会破坏因没回蓝的情况呢？原因是，如果在flash完跑几步就到达终点，此时比原地回蓝优秀；否则你跑着跑着发现就不如回蓝了，那么f[i]也不会被更新，也就是我们的回蓝策略得到了保留。

 # 代码

 ```cpp
#include<cstdio>
const int maxt=300000+50;
using namespace std;
long f[maxt+1],m,s,t;
int main()
{
    scanf("%d %d %d",&m,&s,&t);//读入 
    f[0]=0;
    for (int i=1;i<=t;++i)
        if (m>=10)//蓝量够 
        {
            f[i]=f[i-1]+60;//闪现 
            m-=10;//耗蓝 
        }
        else//缺蓝 
        {
            f[i]=f[i-1];//原地休息 
            m+=4;//回蓝 
        }
    for (int i=1;i<=t;++i)//迭代一遍，如果走路更优那么走路 
    {
        if (f[i]<f[i-1]+17) f[i]=f[i-1]+17;//选走路 
        if (f[i]>=s)//到了 
        {
            printf("Yes\n%d",i);//输出
            return 0;//直接退出程序 
        }
    } 
    printf("No\n%d",f[t]);//必定无解（有解的在循环中已经退了） 
    return 0;
}
 ```