# 适用

单调栈的使用场合为**NGE问题**（Next Greater Element），也就是，**对序列中每个元素**，找到下一个比它大的元素。（当然，“下一个”可以换成“上一个”，“比它大”也可以换成“比他小”，原理不变。）

# 思想

分为四种情况

序列右边第一个比他大的元素

序列右边第一个比他小的元素

序列左边第一个比他大的元素

序列左边第一个比他小的元素



如果是找左边，就从1到n遍历.  对于 i , 如果是找到第一个比他小的，就先弹出栈中比他大的，那么最终的栈顶就是第一个比他小的，之后再入栈. 因此我们维护的是一个递减的.



**总结：** 要的是左边/右边，就从正序/倒序遍历. 弹栈后的栈顶alaways right.

# 例题与其他优秀文章

https://www.luogu.com.cn/problem/solution/P5788

https://zhuanlan.zhihu.com/p/346536592

http://t.zoukankan.com/molinchn-p-14772025.html



## 3 单调栈的使用总结

通过前面的讲解和四个问题，下面我们总结一下单调栈的使用。

| 问题                       | 单调栈的使用                         | 更新的主体 | 产生关系的元素 |
| -------------------------- | ------------------------------------ | ---------- | -------------- |
| 求右侧第一个比自己大的元素 | 从左向右遍历，单调递减栈，出栈时操作 | 出栈元素   | 待入栈元素     |
| 求右侧第一个比自己小的元素 | 从左向右遍历，单调递增栈，出栈时操作 | 出栈元素   | 待入栈元素     |
| 求左侧第一个比自己大的元素 | 从左向右遍历，单调递减栈，入栈时操作 | 入栈元素   | 栈顶元素       |
| 求左侧第一个比自己小的元素 | 从左向右遍历，单调递增栈，入栈时操作 | 入栈元素   | 栈顶元素       |

求左右比自己小的元素，用单调递增栈，入栈时更新左侧最近比自己小的元素，出栈时更新右侧第一个比自己小的元素。同理，求左右比自己大的元素，用单调递减栈，入栈时更新左侧最近比自己大的元素，出栈时更新右侧第一个比自己大的元素。

为了理解上述规律的原因，可以这样思考：**一个元素的生命周期就是被遍历到时入栈，之后遍历到其他元素的时候才有机会出栈。入栈时不知道该元素右侧信息，所以当前只知道左侧信息（即更新左侧第一个比自己大/小的元素)。出栈时知道了是因为右边某个待入栈的元素导致的，是右侧等信息（更新右侧第一个比自己大/小)的元素（如果出栈的时候再不更新，以后也就没机会了）。**

以上都是从左往右遍历，**如果允许从右往左遍历**，那么表格就会变成下面这样：

| 问题                       | 单调栈的使用                         | 更新的主体 | 产生关系的元素 |
| -------------------------- | ------------------------------------ | ---------- | -------------- |
| 求右侧第一个比自己大的元素 | 从右向左遍历，单调递减栈，入栈时操作 | 入栈元素   | 栈顶元素       |
| 求右侧第一个比自己小的元素 | 从右向左遍历，单调递增栈，入栈时操作 | 入栈元素   | 栈顶元素       |
| 求左侧第一个比自己大的元素 | 从右向左遍历，单调递减栈，出栈时操作 | 出栈元素   | 待入栈元素     |
| 求左侧第一个比自己小的元素 | 从右向左遍历，单调递增栈，出栈时操作 | 出栈元素   | 待入栈元素     |

可以发现：只是原来从左向右遍历的表格，把入栈和出栈操作的顺序变换了。为了理解这种变化，还是要从遍历方向与得到信息顺序的角度去看。**从右往左遍历时，对于正在遍历的元素，我们只知道该元素和它的右侧信息。因此对于这个被遍历的元素，第一次操作是入栈时，得到的是右侧的第一个比自己大或小的值。第二次操作是出栈时，得到的是该元素左侧第一个比自己大的值（此时出栈是因为该元素左侧的某个元素引起的，而这个元素就是第一个比自己大或者小的值）。**