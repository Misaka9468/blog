# ST表简介

用于解决RMQ问题：离线区间求最值

其实可以看作是一个动态规划

$dp[i][j]$维护了$i$ 到 $i+2^j-1$ 这个区间的最值, 长度为$2^j$. 也就是说$dp[i][j]$ 为 以i开始2^j 长度区间的最值. 



并且由于max min的可传递性，导致成立

# ST模板及帮助记忆





## ST表的更新/建立

```cpp
    // arr[i][0]代表了维护i到i的最值，也就是其本身
	for(int i=1;i<=N;i++)
       	arr[i][0] = num[i];
	for(int j=1;j<21;j++){ // 先j后i
        for(int i=1;i<=N;i++){
            arr[i][j] = min(arr[i][j-1],arr[i+(1<<(j-1))][j-1]); // 第二点
        }
    }
```

* 要先枚举第二个变量j
  * 因为我们的 $j$ 都是在 $j-1$ 的基础上产生的，而 $i$ 的更新用到了>i的index, 只有保证 j-1 全部更新后才可以
  * **想象一下整个更新过程：先推小区间长度，然后从小区间长度推大区间长度.**  
* 如何记忆这个转移方程
  * $i$到 $i+ 2^j-1$ 的长度是 $2^j$ ，故我们可以分成两半，那么每一半长度是$2^{j-1}$，因此更新用到的下标第二维是 $j-1$
  * 左边 $arr[i][j-1]$ ，右边要保证**精准到 $i + 2^j -1$ 不能多也不能少** 
  * 故右边的 $(i + 2^{j-1}) + 2^{j-1} -1 = i+2^j-1$  所以那个i要这么确定

## ST表的查询

```cpp
int query(int l,int r){
    int k = log2(r-l+1); // 区间长度，由于是闭区间所以要+1
    return min(arr[l][k],arr[r-(1<<k)+1][k]); // 第二点
}
```



* 由于是闭区间，而k代表log2区间长度，所以要 r-l+1
* **要保证我们的查询精准到 $l$ 和 $r$ 不能多不能少，所以 要以这两端为起、终查询**
* 左边很好理解，从 $l $ 向右查询
* 对于右边，保证精准覆盖到$r$ ，在 k已经敲定的前提下，有 $ (r - 2^k +1) +(2^k-1) = r$  故第一维是这么敲定的